// ========================================================================================
//
//                           GNOMON DECISION ENGINE
//
// ========================================================================================
//
// This module contains the hardcoded, high-performance decision logic derived
// from the analysis of benchmark data. The functions within are designed to be
// inlined by the compiler for zero-overhead execution.
//
// The logic herein was automatically generated by the benches/model.py script and
// represents a direct translation of the trained decision tree models. If the models
// are retrained, this file must be updated by re-running the generation script
// and copy-pasting the new output.
//
// ========================================================================================

/// Represents the high-level strategy for an entire application run, chosen once
/// at startup by the meta-model.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum RunStrategy {
    /// Use the simple, no-frequency decision tree for every variant.
    /// This avoids the overhead of calculating allele frequency when the meta-model
    /// determines it is not beneficial.
    UseSimpleTree,
    /// Use the more complex, frequency-aware decision tree for every variant.
    /// This incurs per-variant overhead but may yield better core compute performance
    /// in specific scenarios identified by the meta-model.
    UseComplexTree,
}

/// Represents the chosen compute path for a single variant or batch of variants.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum ComputePath {
    /// The person-major path, efficient for dense variants.
    Pivot,
    /// The variant-major path, efficient for sparse variants.
    NoPivot,
}

/// Contains all necessary parameters to make a pathing decision.
///
/// This context is created on the stack with `f32` types to match the decision
/// logic, avoiding any type casting in the hot path. The calling code is
/// responsible for casting integer-like values (n_cohort, k_scores) once at setup.
#[derive(Debug, Clone, Copy)]
pub struct DecisionContext {
    /// Total number of individuals in the cohort (N).
    pub n_cohort: f32,
    /// Total number of score files being processed (K).
    pub k_scores: f32,
    /// Fraction of the cohort being scored (from --keep file, 1.0 if all).
    pub subset_frac: f32,
    /// Allele frequency of the current variant.
    /// NOTE: This is only used by `decide_path_with_freq`.
    pub freq: f32,
}

// ========================================================================================
//                                  DECISION FUNCTIONS
// ========================================================================================

/// META-MODEL (TREE THREE): Chooses the global run strategy.
///
/// This is called ONCE at the start of the application. It uses run-level
/// parameters (excluding frequency) to decide if it's worth using the
/// more complex, frequency-aware tree.
#[inline(always)]
pub fn choose_run_strategy(ctx: &DecisionContext) -> RunStrategy {
    if ctx.subset_frac <= 0.2750_f32 {
        RunStrategy::UseSimpleTree
    } else if ctx.n_cohort <= 2_236.0677_f32 {
        RunStrategy::UseSimpleTree
    } else if ctx.n_cohort <= 7_071.067_f32 {
        if ctx.subset_frac <= 0.7500_f32 {
            RunStrategy::UseSimpleTree
        } else if ctx.k_scores <= 15.8114_f32 {
            RunStrategy::UseComplexTree
        } else {
            RunStrategy::UseSimpleTree
        }
    } else if ctx.subset_frac <= 0.7500_f32 {
        if ctx.n_cohort <= 20_000.002_f32 {
            if ctx.k_scores <= 15.8114_f32 {
                RunStrategy::UseComplexTree
            } else {
                RunStrategy::UseSimpleTree
            }
        } else if ctx.k_scores <= 70.7107_f32 {
            RunStrategy::UseComplexTree
        } else {
            RunStrategy::UseComplexTree
        }
    } else if ctx.n_cohort <= 20_000.002_f32 {
        if ctx.k_scores <= 15.8114_f32 {
            RunStrategy::UseComplexTree
        } else {
            RunStrategy::UseComplexTree
        }
    } else {
        RunStrategy::UseSimpleTree
    }
}

/// COMPLEX MODEL (TREE ONE): Decides the path using all features, including frequency.
///
/// This is the most accurate logic, used when the meta-model determines
/// that maximum core performance is critical and worth the per-variant
/// overhead of calculating frequency
#[inline(always)]
pub fn decide_path_with_freq(ctx: &DecisionContext) -> ComputePath {
    if ctx.n_cohort <= 20_000.002_f32 {
        if ctx.freq <= 0.0894_f32 {
            if ctx.freq <= 0.0045_f32 {
                if ctx.n_cohort <= 10.0000_f32 {
                    if ctx.subset_frac <= 0.2750_f32 {
                        ComputePath::Pivot
                    } else {
                        ComputePath::NoPivot
                    }
                } else {
                    ComputePath::NoPivot
                }
            } else if ctx.n_cohort <= 7_071.067_f32 {
                if ctx.n_cohort <= 10.0000_f32 {
                    if ctx.subset_frac <= 0.2750_f32 {
                        ComputePath::Pivot
                    } else {
                        ComputePath::NoPivot
                    }
                } else {
                    ComputePath::NoPivot
                }
            } else if ctx.subset_frac <= 0.7500_f32 {
                ComputePath::NoPivot
            } else if ctx.k_scores <= 15.8114_f32 {
                ComputePath::Pivot
            } else {
                ComputePath::NoPivot
            }
        } else if ctx.n_cohort <= 7_071.067_f32 {
            if ctx.k_scores <= 15.8114_f32 {
                if ctx.subset_frac <= 0.7500_f32 {
                    if ctx.n_cohort <= 10.0000_f32 {
                        if ctx.subset_frac <= 0.2750_f32 {
                            ComputePath::Pivot
                        } else {
                            ComputePath::NoPivot
                        }
                    } else {
                        ComputePath::NoPivot
                    }
                } else if ctx.n_cohort <= 2_236.0677_f32 {
                    ComputePath::NoPivot
                } else {
                    ComputePath::Pivot
                }
            } else if ctx.n_cohort <= 10.0000_f32 {
                if ctx.subset_frac <= 0.2750_f32 {
                    ComputePath::Pivot
                } else if ctx.k_scores <= 70.7107_f32 {
                    ComputePath::NoPivot
                } else {
                    ComputePath::NoPivot
                }
            } else {
                ComputePath::NoPivot
            }
        } else if ctx.subset_frac <= 0.7500_f32 {
            if ctx.k_scores <= 15.8114_f32 {
                if ctx.subset_frac <= 0.2750_f32 {
                    if ctx.k_scores <= 2.2361_f32 {
                        ComputePath::NoPivot
                    } else {
                        ComputePath::NoPivot
                    }
                } else {
                    ComputePath::Pivot
                }
            } else {
                ComputePath::NoPivot
            }
        } else {
            ComputePath::Pivot
        }
    } else if ctx.subset_frac <= 0.2750_f32 {
        ComputePath::NoPivot
    } else if ctx.freq <= 0.0045_f32 {
        if ctx.subset_frac <= 0.7500_f32 {
            ComputePath::NoPivot
        } else {
            ComputePath::Pivot
        }
    } else {
        ComputePath::Pivot
    }
}

/// SIMPLE MODEL (TREE TWO): Decides the path without using allele frequency.
///
/// This is the fast, default logic used when the meta-model determines
/// that the overhead of calculating frequency is not worthwhile. For impure
/// leaf nodes, the decision is based on the majority class from the training data.
#[inline(always)]
pub fn decide_path_without_freq(ctx: &DecisionContext) -> ComputePath {
    if ctx.n_cohort <= 20_000.002_f32 {
        if ctx.n_cohort <= 7_071.067_f32 {
            if ctx.k_scores <= 15.8114_f32 {
                if ctx.subset_frac <= 0.7500_f32 {
                    if ctx.n_cohort <= 10.0000_f32 {
                        if ctx.subset_frac <= 0.2750_f32 {
                            ComputePath::Pivot
                        } else {
                            ComputePath::NoPivot
                        }
                    } else {
                        ComputePath::NoPivot
                    }
                } else if ctx.n_cohort <= 2_236.0677_f32 {
                    ComputePath::NoPivot
                } else if ctx.k_scores <= 2.2361_f32 {
                    // Impure node, No-Pivot is majority class [0.839 > 0.160]
                    ComputePath::NoPivot
                } else {
                    // Impure node, No-Pivot is majority class [0.826 > 0.173]
                    ComputePath::NoPivot
                }
            } else if ctx.n_cohort <= 10.0000_f32 {
                if ctx.subset_frac <= 0.2750_f32 {
                    ComputePath::Pivot
                } else {
                    ComputePath::NoPivot
                }
            } else {
                ComputePath::NoPivot
            }
        } else if ctx.subset_frac <= 0.7500_f32 {
            if ctx.k_scores <= 15.8114_f32 {
                if ctx.subset_frac <= 0.2750_f32 {
                    ComputePath::NoPivot
                } else if ctx.k_scores <= 2.2361_f32 {
                    // Impure node, No-Pivot is majority class [0.728 > 0.271]
                    ComputePath::NoPivot
                } else {
                    // Impure node, No-Pivot is majority class [0.813 > 0.186]
                    ComputePath::NoPivot
                }
            } else {
                ComputePath::NoPivot
            }
        } else if ctx.k_scores <= 70.7107_f32 {
            if ctx.k_scores <= 15.8114_f32 {
                if ctx.k_scores <= 2.2361_f32 {
                    // Impure node, Pivot is majority class [0.907 > 0.092]
                    ComputePath::Pivot
                } else {
                    // Impure node, Pivot is majority class [0.910 > 0.089]
                    ComputePath::Pivot
                }
            } else {
                // Impure node, Pivot is majority class [0.860 > 0.139]
                ComputePath::Pivot
            }
        } else {
            // Impure node, Pivot is majority class [0.707 > 0.292]
            ComputePath::Pivot
        }
    } else if ctx.subset_frac <= 0.2750_f32 {
        ComputePath::NoPivot
    } else if ctx.subset_frac <= 0.7500_f32 {
        if ctx.k_scores <= 70.7107_f32 {
            if ctx.k_scores <= 15.8114_f32 {
                if ctx.k_scores <= 2.2361_f32 {
                    // Impure node, Pivot is majority class [0.950 > 0.049]
                    ComputePath::Pivot
                } else {
                    // Impure node, Pivot is majority class [0.950 > 0.049]
                    ComputePath::Pivot
                }
            } else {
                // Impure node, Pivot is majority class [0.925 > 0.074]
                ComputePath::Pivot
            }
        } else {
            // Impure node, Pivot is majority class [0.705 > 0.294]
            ComputePath::Pivot
        }
    } else {
        ComputePath::Pivot
    }
}
