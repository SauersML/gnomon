name: Lean Prover CI

on:
  schedule:
    - cron: '*/140 * * * *'
  push:
    branches: [ "main" ]
    paths:
      - 'proofs/**'
      - 'lakefile.lean'
      - 'lean-toolchain'
      - '.github/workflows/prover.yml'
  pull_request:
    branches: [ "main" ]
    paths:
      - 'proofs/**'
      - 'lakefile.lean'
      - 'lean-toolchain'
      - '.github/workflows/prover.yml'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

jobs:
  prove:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        
      - name: Install elan
        run: |
          curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf | sh -s -- -y
          echo "$HOME/.elan/bin" >> $GITHUB_PATH
          
      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

          
      - name: Cache Lean toolchain
        uses: actions/cache@v4
        with:
          path: ~/.elan
          key: ${{ runner.os }}-elan-${{ hashFiles('lean-toolchain') }}
          
      - name: Cache everything Lake-related
        id: cache-lake-all
        uses: actions/cache@v4
        with:
          path: |
            .lake
          key: ${{ runner.os }}-lake-v5-${{ hashFiles('lean-toolchain', 'lake-manifest.json') }}
          restore-keys: |
            ${{ runner.os }}-lake-v5-${{ hashFiles('lean-toolchain') }}-
            
      - name: Enforce manifest integrity
        run: |
          # Failsafe: Ensure the cache never overwrites our locked dependencies.
          # Even if someone accidentally adds lake-manifest.json back to the cache paths,
          # this un-does the damage immediately.
          git restore lake-manifest.json
            
      - name: Verify cache completeness
        id: check-cache
        run: |
          echo "üîç Checking cache completeness..."
          
          # Check if .lake directory exists
          if [ ! -d ".lake" ]; then
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "‚ùå No .lake directory found"
            exit 0
          fi
          
          # Check for all expected packages and their builds
          EXPECTED_PACKAGES=(
            "mathlib"
            "aesop"
            "batteries"
            "proofwidgets"
            "Qq"
            "plausible"
            "LeanSearchClient"
            "importGraph"
            "Cli"
          )
          
          ALL_FOUND=true
          for pkg in "${EXPECTED_PACKAGES[@]}"; do
            if [ ! -d ".lake/packages/$pkg" ]; then
              echo "‚ö†Ô∏è  Missing package: $pkg"
              ALL_FOUND=false
            else
              # Check if package has build artifacts
              if [ ! -d ".lake/packages/$pkg/.lake" ] && [ ! -d ".lake/build" ]; then
                echo "‚ö†Ô∏è  Missing build artifacts for: $pkg"
                ALL_FOUND=false
              fi
            fi
          done
          
          if [ "$ALL_FOUND" = true ]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Complete cache found with all packages and builds!"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "‚ùå Cache incomplete, will rebuild"
          fi
          
      - name: Update and fetch dependencies (only if cache miss)
        if: steps.check-cache.outputs.valid != 'true'
        run: |
          echo "üì¶ Cache miss - updating dependencies..."
          # lake update  <-- REMOVED: Do not update dependencies, use the lockfile!
          

          
          echo "üì• Downloading mathlib cache..."
          # The '|| true' is REMOVED. We MUST succeed in getting the cache
          # because building Mathlib from source is not viable in CI.
          lake exe cache get
          
      - name: Build all dependencies (only if cache miss)
        if: steps.check-cache.outputs.valid != 'true'
        run: |
          echo "üî® Building ALL dependencies (this will take a few minutes)..."
          # First, ensure all dependencies are fetched (already done above, but safe to repeat)
          # lake build --no-build || true  <-- Moved up
          # Then build everything to populate the cache
          lake build
          echo "‚úÖ All dependencies built and ready for caching!"


      - name: üîç Deep Debug Information
        if: always() # Always run this step for maximum visibility
        run: |
          echo "================================================="
          echo "üìÑ CONFIGURATION FILES"
          echo "================================================="
          echo "--- lakefile.lean ---"
          cat lakefile.lean
          echo ""
          echo "--- lean-toolchain ---"
          cat lean-toolchain
          echo "================================================="
          echo ""

          echo "================================================="
          echo "üå≥ DIRECTORY STRUCTURE"
          echo "================================================="
          ls -R
          echo "================================================="
          echo ""
          
          echo "================================================="
          echo "üî¨ VERBOSE BUILD LOG"
          echo "================================================="
          # The '-v' (verbose) flag is the most important debugging tool.
          # It shows every command Lake runs, revealing exactly what
          # files are (or are not) being compiled.
          lake build -v Calibrator
          echo "================================================="
          echo ""
          
      - name: Quick build of project
        run: |
          echo "üöÄ Building Calibrator (should be instant with cache)..."
          lake build Calibrator
          
      - name: Display build statistics
        if: always()
        run: |
          echo "üìä Build Statistics:"
          echo "===================="
          echo "Build completed at: $(date -u)"
          
          if [ "${{ steps.check-cache.outputs.valid }}" == "true" ]; then
            echo "‚ú® FAST BUILD - Used complete cache!"
            echo "‚ö° Only compiled project-specific files"
          else
            echo "üêå SLOW BUILD - Had to build all dependencies"
            echo "üíæ But next build will be fast!"
          fi
          
          # Show cache size info
          if [ -d ".lake" ]; then
            echo ""
            echo "üì¶ Cache size: $(du -sh .lake | cut -f1)"
            echo "üìÅ Package count: $(ls -1 .lake/packages 2>/dev/null | wc -l)"
          fi
          
      - name: Validate build outputs
        run: |
          echo "================================================="
          if [ -f ".lake/build/lib/lean/Calibrator.olean" ]; then
            echo "‚úÖ SUCCESS: .lake/build/lib/lean/Calibrator.olean was created."
          else
            echo "‚ùå FAILURE: .lake/build/lib/lean/Calibrator.olean was NOT found."
            exit 1
          fi

  auto-close-failed-proof-pr:
    runs-on: ubuntu-latest
    needs: prove
    # IMPORTANT: always() ensures this job runs even if prove fails
    if: always() && github.event_name == 'pull_request'
    steps:
      - name: Close PR if proofs/ or Lean rules violated
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request context; skipping.');
              return;
            }

            const files = await github.paginate(
              github.rest.pulls.listFiles,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                per_page: 100,
              }
            );

            const touchesProofs = files.some((file) => file.filename.startsWith('proofs/'));
            const touchesLean = files.some((file) =>
              file.filename.startsWith('proofs/') ||
              file.filename === 'lakefile.lean' ||
              file.filename === 'lean-toolchain' ||
              file.filename === '.github/workflows/prover.yml'
            );
            const addsNewFiles = files.some((file) => file.status === 'added');

            const commits = await github.paginate(
              github.rest.pulls.listCommits,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                per_page: 100,
              }
            );
            const hasJulesCommit = commits.some((c) => {
              const name = (c.commit && c.commit.author && c.commit.author.name) || '';
              return name.toLowerCase().includes('jules');
            });
            
            // Also detect Jules PRs by branch name pattern
            const branchName = pr.head.ref;
            const julesApiBranchPattern = /^fix-(calibrator|proofs|build).*-\d+$/;
            const julesScriptBranchPattern = /^jules-improvement-\d{8}-\d{6}$/;
            const hasJulesBranch = julesApiBranchPattern.test(branchName) || julesScriptBranchPattern.test(branchName);
            const isJulesPR = hasJulesCommit || hasJulesBranch;

            const proverFailed = '${{ needs.prove.result }}' === 'failure';

            // Close if: (touches proofs AND failed) OR (is Jules PR AND failed) OR (adds new files to Lean paths)
            const shouldClose =
              (touchesProofs && proverFailed) ||
              (isJulesPR && proverFailed) ||
              (touchesLean && addsNewFiles);

            if (!shouldClose) {
              core.info('No auto-close conditions met; skipping.');
              return;
            }

            const body = [
              '## ‚ùå Lean Prover CI Failed',
              '',
              'This PR was auto-closed due to one or more rules:',
              `- Touches \`proofs/\` and Lean Prover CI failed: ${touchesProofs && proverFailed ? 'yes' : 'no'}`,
              `- Jules PR (detected by branch pattern or commit author) and build failed: ${isJulesPR && proverFailed ? 'yes' : 'no'}`,
              `- Touches Lean-related files and adds new files: ${touchesLean && addsNewFiles ? 'yes' : 'no'}`,
              '',
              `Branch: \`${branchName}\``,
              `Jules PR detected: ${isJulesPR ? 'yes' : 'no'} (branch pattern: ${hasJulesBranch}, commit author: ${hasJulesCommit})`,
              '',
              'Please fix the issue(s) and reopen when ready.',
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body,
            });

            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              state: 'closed',
            });

            core.setFailed('Lean Prover CI failed for PR that modifies proofs/.');
