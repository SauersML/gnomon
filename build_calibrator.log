âœ– [3220/3221] Building Calibrator (77s)
trace: .> LEAN_PATH=/app/.lake/packages/Cli/.lake/build/lib/lean:/app/.lake/packages/batteries/.lake/build/lib/lean:/app/.lake/packages/Qq/.lake/build/lib/lean:/app/.lake/packages/aesop/.lake/build/lib/lean:/app/.lake/packages/proofwidgets/.lake/build/lib/lean:/app/.lake/packages/importGraph/.lake/build/lib/lean:/app/.lake/packages/LeanSearchClient/.lake/build/lib/lean:/app/.lake/packages/plausible/.lake/build/lib/lean:/app/.lake/packages/mathlib/.lake/build/lib/lean:/app/.lake/build/lib/lean /home/jules/.elan/toolchains/leanprover--lean4---v4.26.0/bin/lean /app/proofs/Calibrator.lean -o /app/.lake/build/lib/lean/Calibrator.olean -i /app/.lake/build/lib/lean/Calibrator.ilean -c /app/.lake/build/ir/Calibrator.c --setup /app/.lake/build/ir/Calibrator.setup.json --json
warning: proofs/Calibrator.lean:430:33: This simp argument is unused:
  zero_mul

Hint: Omit it from the simp argument list.
  simp only [mul_zero, add_zero, zÌµeÌµrÌµoÌµ_ÌµmÌµuÌµlÌµ,Ìµ Ìµmul_one] at h0 h1

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1188:29: This simp argument is unused:
  ha_def

Hint: Omit it from the simp argument list.
  simp only [model', haÌµ_ÌµdÌµeÌµfÌµ,Ìµ ÌµhÌµb_def] at h

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1188:37: This simp argument is unused:
  hb_def

Hint: Omit it from the simp argument list.
  simp only [model', ha_def,Ìµ ÌµhÌµbÌµ_ÌµdÌµeÌµfÌµ] at h

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1189:32: 'ring' tactic does nothing

Note: This linter can be disabled with `set_option linter.unusedTactic false`
warning: proofs/Calibrator.lean:1189:32: this tactic is never executed

Note: This linter can be disabled with `set_option linter.unreachableTactic false`
warning: proofs/Calibrator.lean:1488:3: unused variable `h_indep`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
warning: proofs/Calibrator.lean:1489:3: unused variable `h_true_fn`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
warning: proofs/Calibrator.lean:1499:78: unused variable `h_norm`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
warning: proofs/Calibrator.lean:1698:34: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1701:34: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1742:28: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1747:35: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1735:66: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1738:44: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1754:30: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1759:30: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1770:68: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1773:46: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1792:30: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1796:31: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1803:32: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1807:32: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1815:32: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1821:30: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1826:32: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1831:33: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1837:37: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1843:30: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1848:37: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:1778:56: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [g, ParamIx.equivSum, mul_assoc, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1850:79: This simp argument is unused:
  Finset.sum_mul

Hint: Omit it from the simp argument list.
  simp [linearPredictor, evalSmooth, Finset.sum_add_distrib, Finset.mul_sum, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµmÌµuÌµlÌµ,Ìµadd_mul, mul_add,
  Ì²  Ì² Ì² Ì² Ì² Ì²mul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1851:6: This simp argument is unused:
  add_mul

Hint: Omit it from the simp argument list.
  simp [linearPredictor, evalSmooth, Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul,
        aÌµdÌµdÌµ_Ìµmul,Ìµ ÌµmÌµuÌµlÌµ_add, mul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1851:34: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [linearPredictor, evalSmooth, Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul,
        add_mul, mul_add, mul_comm, mul_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1851:49: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [linearPredictor, evalSmooth, Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul,
        add_mul, mul_add, mul_comm, mul_left_comm,Ìµ ÌµmÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1852:29: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [hsum_pc, hsum_int, mul_cÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµl_ÌµlÌµeft_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1852:39: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [hsum_pc, hsum_int, mul_comm, mul_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:1852:54: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [hsum_pc, hsum_int, mul_comm, mul_left_comm,Ìµ ÌµmÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2017:4: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:2027:31: Try `simp at this` instead of `simpa using this`

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:2041:38: This simp argument is unused:
  norm_norm

Hint: Omit it from the simp argument list.
  simp [u, norm_smul, norm_inv, nÌµoÌµrÌµmÌµ_ÌµnÌµoÌµrÌµmÌµ,Ìµ Ìµhnorm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2223:20: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:2225:20: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:2179:66: This simp argument is unused:
  Finset.sum_mul

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµmÌµuÌµlÌµ,Ìµ Ìµsub_eq_add_neg, add_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²add_left_comm, add_assoc, mul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2180:22: This simp argument is unused:
  add_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_cÌµoÌµmÌµmÌµ,Ìµ ÌµaÌµdÌµdÌµ_Ìµleft_comm, add_assoc, mul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2180:32: This simp argument is unused:
  add_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_comm, add_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµadÌµdÌµ_ÌµaÌµssoc, mul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2180:47: This simp argument is unused:
  add_assoc

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_comm, add_left_comm, aÌµdÌµdÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ,Ìµ Ìµmul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2180:68: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_comm, add_left_comm, add_assoc, mul_comm, mul_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2180:83: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_comm, add_left_comm, add_assoc, mul_comm, mul_left_comm,Ìµ ÌµmÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2190:14: This simp argument is unused:
  Finset.sum_ite_eq'

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµiÌµtÌµeÌµ_ÌµeÌµqÌµ'Ìµ,Ìµ ÌµFinset.sum_ite_eq, mul_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2190:63: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2190:78: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ]ÌµmÌ²uÌ²lÌ²_Ì²lÌ²eÌ²fÌ²tÌ²_Ì²cÌ²oÌ²mÌ²mÌ²]Ì²

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2191:46: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [hSi, s, mul_comm, mul_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc, mul_self_nonneg]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2191:61: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [hSi, s, mul_comm, mul_left_comm, mul_aÌµssÌµoÌµcÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµsÌµelf_nonneg]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2210:37: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [dotProduct, pow_two,Ìµ ÌµmÌµuÌµlÌµ_ÌµcÌµoÌµmÌµmÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2214:28: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [dotProduct,Ìµ ÌµmÌµuÌµlÌµ_ÌµcÌµoÌµmÌµmÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2383:20: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:2385:20: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:2340:66: This simp argument is unused:
  Finset.sum_mul

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµmÌµuÌµlÌµ,Ìµ Ìµsub_eq_add_neg, add_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²add_left_comm, add_assoc, mul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2341:22: This simp argument is unused:
  add_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_cÌµoÌµmÌµmÌµ,Ìµ ÌµaÌµdÌµdÌµ_Ìµleft_comm, add_assoc, mul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2341:32: This simp argument is unused:
  add_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_comm, add_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµadÌµdÌµ_ÌµaÌµssoc, mul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2341:47: This simp argument is unused:
  add_assoc

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_comm, add_left_comm, aÌµdÌµdÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ,Ìµ Ìµmul_comm, mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2341:68: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_comm, add_left_comm, add_assoc, mul_comm, mul_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2341:83: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                        add_comm, add_left_comm, add_assoc, mul_comm, mul_left_comm,Ìµ ÌµmÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2351:14: This simp argument is unused:
  Finset.sum_ite_eq'

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµiÌµtÌµeÌµ_ÌµeÌµqÌµ'Ìµ,Ìµ ÌµFinset.sum_ite_eq, mul_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2351:63: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2351:78: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ]ÌµmÌ²uÌ²lÌ²_Ì²lÌ²eÌ²fÌ²tÌ²_Ì²cÌ²oÌ²mÌ²mÌ²]Ì²

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2352:46: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [hSi, s, mul_comm, mul_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc, mul_self_nonneg]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2352:61: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [hSi, s, mul_comm, mul_left_comm, mul_aÌµssÌµoÌµcÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµsÌµelf_nonneg]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2370:37: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [dotProduct, pow_two,Ìµ ÌµmÌµuÌµlÌµ_ÌµcÌµoÌµmÌµmÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2374:28: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [dotProduct,Ìµ ÌµmÌµuÌµlÌµ_ÌµcÌµoÌµmÌµmÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2427:44: This simp argument is unused:
  Pi.sub_apply

Hint: Omit it from the simp argument list.
  simp [pointwiseNLL, hm.dist_gaussian, PÌµiÌµ.ÌµsÌµuÌµbÌµ_ÌµaÌµpÌµpÌµlÌµyÌµ,Ìµ Ìµh_lin, X]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2432:8: This simp argument is unused:
  Finset.sum_ite_eq'

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµiÌµtÌµeÌµ_ÌµeÌµqÌµ'Ìµ,Ìµ ÌµFinset.sum_ite_eq, mul_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2432:57: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2432:72: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ]ÌµmÌ²uÌ²lÌ²_Ì²lÌ²eÌ²fÌ²tÌ²_Ì²cÌ²oÌ²mÌ²mÌ²]Ì²

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2443:41: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [h_diag, pow_two, mul_comm, mul_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2493:52: This simp argument is unused:
  Finset.sum_add_distrib

Hint: Omit it from the simp argument list.
  simp [g, ParamIxSum, hsum_pc, hsum_int,Ìµ ÌµFÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµaÌµdÌµdÌµ_ÌµdÌµiÌµsÌµtÌµrÌµiÌµbÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2679:73: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:2778:10: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:2635:54: This simp argument is unused:
  Finset.sum_mul

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµmÌµuÌµlÌµ,Ìµ Ìµsub_eq_add_neg, add_comm, add_left_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²add_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2636:10: This simp argument is unused:
  add_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg, aÌµdÌµdÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµadd_left_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²add_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2636:20: This simp argument is unused:
  add_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg, add_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²aÌµdÌµdÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµadd_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2640:30: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.mul_sum, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2640:45: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [Finset.mul_sum, mul_left_comm, mul_cÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2712:62: This simp argument is unused:
  Finset.sum_mul

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµmÌµuÌµlÌµ,Ìµ Ìµsub_eq_add_neg, add_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²add_left_comm, add_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2713:18: This simp argument is unused:
  add_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                    add_cÌµoÌµmÌµmÌµ,Ìµ ÌµaÌµdÌµdÌµ_Ìµleft_comm, add_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2713:28: This simp argument is unused:
  add_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_mul, sub_eq_add_neg,
                    add_comm, add_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµadÌµdÌµ_ÌµaÌµssoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2717:61: This simp argument is unused:
  Matrix.mulVec_sub

Hint: Omit it from the simp argument list.
  simp [Matrix.mulVec_add, Matrix.mulVec_smul, MÌµaÌµtÌµrÌµiÌµxÌµ.ÌµmÌµuÌµlÌµVÌµeÌµcÌµ_ÌµsÌµuÌµbÌµ,Ìµ ÌµMatrix.mulVec_neg, Pi.add_apply,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²Pi.sub_apply, Pi.neg_apply, Pi.smul_apply, smul_eq_mul, mul_add, add_mul,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²sub_eq_add_neg, hb']

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2722:38: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.mul_sum, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:2887:15: unused variable `hlam`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
warning: proofs/Calibrator.lean:2887:32: unused variable `hS_posDef`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
warning: proofs/Calibrator.lean:3205:58: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:3206:57: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:3250:18: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:3303:18: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:3252:40: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [Finset.mul_sum, mÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ,Ìµ Ìµmul_left_comm, mul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3252:51: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.mul_sum, mul_assoc, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3252:66: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [Finset.mul_sum, mul_assoc, mul_left_comm,Ìµ ÌµmÌµuÌµlÌµ_ÌµcÌµoÌµmÌµmÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3284:64: This simp argument is unused:
  mul_add

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mÌµuÌµlÌµ_ÌµaÌµdÌµdÌµ,Ìµ Ìµadd_mul, mul_assoc, mul_left_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3284:73: This simp argument is unused:
  add_mul

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mul_add, aÌµdÌµdÌµ_ÌµmÌµuÌµlÌµ,Ìµ Ìµmul_assoc, mul_left_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3284:82: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mul_add, add_mul, mÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ,Ìµ Ìµmul_left_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3284:93: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mul_add, add_mul, mul_assoc,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3284:108: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mul_add, add_mul, mul_assoc,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµcÌµoÌµmÌµmÌµ]ÌµmÌ²uÌ²lÌ²_Ì²lÌ²eÌ²fÌ²tÌ²_Ì²cÌ²oÌ²mÌ²mÌ²]Ì²

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3337:64: This simp argument is unused:
  mul_add

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mÌµuÌµlÌµ_ÌµaÌµdÌµdÌµ,Ìµ Ìµadd_mul, mul_assoc, mul_left_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3337:73: This simp argument is unused:
  add_mul

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mul_add, aÌµdÌµdÌµ_ÌµmÌµuÌµlÌµ,Ìµ Ìµmul_assoc, mul_left_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3337:82: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mul_add, add_mul, mÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ,Ìµ Ìµmul_left_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3337:93: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mul_add, add_mul, mul_assoc,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_comm]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3337:108: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [Finset.sum_add_distrib, Finset.mul_sum, mul_add, add_mul, mul_assoc,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµcÌµoÌµmÌµmÌµ]ÌµmÌ²uÌ²lÌ²_Ì²lÌ²eÌ²fÌ²tÌ²_Ì²cÌ²oÌ²mÌ²mÌ²]Ì²

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3359:10: This simp argument is unused:
  Finset.sum_ite_eq'

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµiÌµtÌµeÌµ_ÌµeÌµqÌµ'Ìµ,Ìµ ÌµFinset.sum_ite_eq, mul_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3359:59: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3359:74: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ]ÌµmÌ²uÌ²lÌ²_Ì²lÌ²eÌ²fÌ²tÌ²_Ì²cÌ²oÌ²mÌ²mÌ²]Ì²

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3360:33: This simp argument is unused:
  mul_comm

Hint: Omit it from the simp argument list.
  simp [s, hmul, mul_cÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµl_ÌµlÌµeft_comm, mul_assoc, mul_self_nonneg]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3360:43: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [s, hmul, mul_comm, mul_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc, mul_self_nonneg]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3360:58: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [s, hmul, mul_comm, mul_left_comm, mul_aÌµssÌµoÌµcÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµsÌµelf_nonneg]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3383:10: This simp argument is unused:
  Finset.sum_ite_eq'

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, FÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµiÌµtÌµeÌµ_ÌµeÌµqÌµ'Ìµ,Ìµ ÌµFinset.sum_ite_eq, mul_comm,
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²mul_left_comm, mul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3383:59: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ Ìµmul_assoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3383:74: This simp argument is unused:
  mul_assoc

Hint: Omit it from the simp argument list.
  simp [S, Matrix.mulVec, dotProduct, Matrix.diagonal_apply, Finset.sum_ite_eq',
  Ì²  Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì² Ì²Finset.sum_ite_eq, mul_comm, mÌµuÌµlÌµ_ÌµlÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_ÌµaÌµsÌµsÌµoÌµcÌµ]ÌµmÌ²uÌ²lÌ²_Ì²lÌ²eÌ²fÌ²tÌ²_Ì²cÌ²oÌ²mÌ²mÌ²]Ì²

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3394:43: This simp argument is unused:
  mul_left_comm

Hint: Omit it from the simp argument list.
  simp [h_diag, pow_two, mul_comm, mul_lÌµeÌµfÌµtÌµ_ÌµcÌµoÌµmÌµmÌµ,Ìµ ÌµmÌµuÌµlÌµ_Ìµassoc]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3443:50: This simp argument is unused:
  Finset.sum_add_distrib

Hint: Omit it from the simp argument list.
  simp [ParamIxSum, g, hsum_pc, hsum_int,Ìµ ÌµFÌµiÌµnÌµsÌµeÌµtÌµ.ÌµsÌµuÌµmÌµ_ÌµaÌµdÌµdÌµ_ÌµdÌµiÌµsÌµtÌµrÌµiÌµbÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:3873:5: unused variable `hf_int`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
error: proofs/Calibrator.lean:4127:47: expected token
error: proofs/Calibrator.lean:4003:40: failed to synthesize
  LE Type

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
error: proofs/Calibrator.lean:4003:42: failed to synthesize
  OfNat Type 0
numerals are polymorphic in Lean, but the numeral `0` cannot be used in a context where the expected type is
  Type
due to the absence of the instance above

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
error: proofs/Calibrator.lean:4003:101: failed to synthesize
  LE Type

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
error: proofs/Calibrator.lean:4003:103: failed to synthesize
  OfNat Type 0
numerals are polymorphic in Lean, but the numeral `0` cannot be used in a context where the expected type is
  Type
due to the absence of the instance above

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
error: proofs/Calibrator.lean:4007:28: Application type mismatch: The argument
  Nat.cast_ne_zero.mpr (Nat.succ_ne_zero n)
has type
  â†‘n.succ â‰  @OfNat.ofNat ?m.723 0 (@Zero.toOfNat0 ?m.723 AddMonoidWithOne.toAddMonoid.toAddZeroClass.toZero)
but is expected to have type
  ?m.722 â‰ 
    @OfNat.ofNat ?m.720 0 (@Zero.toOfNat0 ?m.720 GroupWithZero.toMonoidWithZero.toMulZeroOneClass.toMulZeroClass.toZero)
in the application
  div_self (Nat.cast_ne_zero.mpr (Nat.succ_ne_zero n))
error: proofs/Calibrator.lean:4053:8: `simp` made no progress
error: proofs/Calibrator.lean:4065:61: Unknown constant `ENNReal.one_toReal`
warning: proofs/Calibrator.lean:4066:16: `MeasureTheory.integral_mul_left` has been deprecated: Use `MeasureTheory.integral_const_mul` instead
error: proofs/Calibrator.lean:4066:35: Unknown identifier `integral_id_gaussianReal`
warning: proofs/Calibrator.lean:4068:16: `MeasureTheory.integral_mul_left` has been deprecated: Use `MeasureTheory.integral_const_mul` instead
error: proofs/Calibrator.lean:4068:16: Tactic `rewrite` failed: Did not find an occurrence of the pattern
  âˆ« (a : ?m.1318), ?r * ?f a âˆ‚?m.1320
in the target expression
  Integrable (fun a => predictorBase m c ^ 2) Î¼P

case hf
k : â„•
instâœ : Fintype (Fin k)
scaling_func : (Fin k â†’ â„) â†’ â„
h_scaling_meas : AEStronglyMeasurable scaling_func (Measure.map Prod.snd (stdNormalProdMeasure k))
h_integrable : Integrable (fun pc => (scaling_func pc.2 * pc.1) ^ 2) (stdNormalProdMeasure k)
h_scaling_sq_int : Integrable (fun c => scaling_func c ^ 2) (Measure.map Prod.snd (stdNormalProdMeasure k))
h_mean_1 : âˆ« (c : Fin k â†’ â„), scaling_func c âˆ‚Measure.map Prod.snd (stdNormalProdMeasure k) = 1
model_norm : PhenotypeInformedGAM 1 k 1
h_norm_opt : IsBayesOptimalInNormalizedClass (dgpMultiplicativeBias scaling_func) model_norm
h_linear_basis : model_norm.pgsBasis.B 1 = id âˆ§ model_norm.pgsBasis.B 0 = fun x => 1
h_norm_int : Integrable (fun pc => linearPredictor model_norm pc.1 pc.2 ^ 2) (stdNormalProdMeasure k)
h_base_meas : AEStronglyMeasurable (predictorBase model_norm) (Measure.map Prod.snd (stdNormalProdMeasure k))
model_oracle : PhenotypeInformedGAM 1 k 1
h_oracle_opt : IsBayesOptimalInClass (dgpMultiplicativeBias scaling_func) model_oracle
h_capable :
  âˆƒ m,
    âˆ€ (p_val : â„) (c_val : Fin k â†’ â„),
      linearPredictor m p_val c_val = (dgpMultiplicativeBias scaling_func).trueExpectation p_val c_val
dgp : DataGeneratingProcess k := dgpMultiplicativeBias scaling_func
h_oracle_risk_zero : (expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) = 0
h_diff_eq_norm_sq :
  ((expectedSquaredError dgp fun p c => linearPredictor model_norm p c) -
      expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)),
      (dgp.trueExpectation pc.1 pc.2 - linearPredictor model_norm pc.1 pc.2) ^ 2 âˆ‚dgp.jointMeasure
model_star : PhenotypeInformedGAM 1 k 1 :=
  { pgsBasis := model_norm.pgsBasis, pcSplineBasis := model_norm.pcSplineBasis, Î³â‚€â‚€ := 0, Î³â‚˜â‚€ := fun x => 1,
    fâ‚€â‚— := fun x x_1 => 0, fâ‚˜â‚— := fun x x_1 x_2 => 0, link := model_norm.link, dist := model_norm.dist }
h_star_pred : âˆ€ (p : â„) (c : Fin k â†’ â„), linearPredictor model_star p c = p
h_star_in_class : IsNormalizedScoreModel model_star
h_risk_star :
  (expectedSquaredError (dgpMultiplicativeBias scaling_func) fun p c => linearPredictor model_star p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)), ((scaling_func pc.2 - 1) * pc.1) ^ 2 âˆ‚stdNormalProdMeasure k
m : PhenotypeInformedGAM 1 k 1 := model_norm
hm_norm : IsNormalizedScoreModel model_norm
Î¼P : Measure â„ := ProbabilityTheory.gaussianReal 0 1
Î¼C : Measure (Fin k â†’ â„) := Measure.pi fun x => ProbabilityTheory.gaussianReal 0 1
h_prod : stdNormalProdMeasure k = Î¼P.prod Î¼C
thisâœ : IsProbabilityMeasure Î¼P
this : IsProbabilityMeasure Î¼C
h_gauss_moments : âˆ€ (n : â„•), Integrable (fun x => x ^ n) Î¼P
h_p_int : Integrable (fun p => p) Î¼P
h_p2_int : Integrable (fun p => p ^ 2) Î¼P
h_map : Measure.map Prod.snd (stdNormalProdMeasure k) = Î¼C
h_scaling_meas' : AEStronglyMeasurable scaling_func Î¼C
h_scaling_sq_int' : Integrable (fun c => scaling_func c ^ 2) Î¼C
h_S_int : Integrable scaling_func Î¼C
h_Sm1_int : Integrable (fun c => scaling_func c - 1) Î¼C
k_val : â„ := m.Î³â‚˜â‚€ 0
f : â„ Ã— (Fin k â†’ â„) â†’ â„ := fun pc => (predictorBase m pc.2 + k_val * pc.1) ^ 2
h_int_f : Integrable f (Î¼P.prod Î¼C)
c : Fin k â†’ â„
h_poly :
  âˆ€ (p : â„),
    (predictorBase m c + k_val * p) ^ 2 = predictorBase m c ^ 2 + 2 * predictorBase m c * k_val * p + k_val ^ 2 * p ^ 2
âŠ¢ Integrable (fun a => predictorBase m c ^ 2) Î¼P
error: proofs/Calibrator.lean:4073:10: Tactic `apply` failed: could not unify the conclusion of `@Integrable.const_mul`
  Integrable (fun x => ?c * ?f x) ?Î¼
with the goal
  Integrable (fun p => predictorBase m c ^ 2 + 2 * predictorBase m c * k_val * p) Î¼P

Note: The full type of `@Integrable.const_mul` is
  âˆ€ {Î± : Type ?u.326387} {m : MeasurableSpace Î±} {Î¼ : Measure Î±} {ð•œ : Type ?u.326386} [inst : NormedRing ð•œ] {f : Î± â†’ ð•œ},
    Integrable f Î¼ â†’ âˆ€ (c : ð•œ), Integrable (fun x => c * f x) Î¼

case hf
k : â„•
instâœ : Fintype (Fin k)
scaling_func : (Fin k â†’ â„) â†’ â„
h_scaling_meas : AEStronglyMeasurable scaling_func (Measure.map Prod.snd (stdNormalProdMeasure k))
h_integrable : Integrable (fun pc => (scaling_func pc.2 * pc.1) ^ 2) (stdNormalProdMeasure k)
h_scaling_sq_int : Integrable (fun c => scaling_func c ^ 2) (Measure.map Prod.snd (stdNormalProdMeasure k))
h_mean_1 : âˆ« (c : Fin k â†’ â„), scaling_func c âˆ‚Measure.map Prod.snd (stdNormalProdMeasure k) = 1
model_norm : PhenotypeInformedGAM 1 k 1
h_norm_opt : IsBayesOptimalInNormalizedClass (dgpMultiplicativeBias scaling_func) model_norm
h_linear_basis : model_norm.pgsBasis.B 1 = id âˆ§ model_norm.pgsBasis.B 0 = fun x => 1
h_norm_int : Integrable (fun pc => linearPredictor model_norm pc.1 pc.2 ^ 2) (stdNormalProdMeasure k)
h_base_meas : AEStronglyMeasurable (predictorBase model_norm) (Measure.map Prod.snd (stdNormalProdMeasure k))
model_oracle : PhenotypeInformedGAM 1 k 1
h_oracle_opt : IsBayesOptimalInClass (dgpMultiplicativeBias scaling_func) model_oracle
h_capable :
  âˆƒ m,
    âˆ€ (p_val : â„) (c_val : Fin k â†’ â„),
      linearPredictor m p_val c_val = (dgpMultiplicativeBias scaling_func).trueExpectation p_val c_val
dgp : DataGeneratingProcess k := dgpMultiplicativeBias scaling_func
h_oracle_risk_zero : (expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) = 0
h_diff_eq_norm_sq :
  ((expectedSquaredError dgp fun p c => linearPredictor model_norm p c) -
      expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)),
      (dgp.trueExpectation pc.1 pc.2 - linearPredictor model_norm pc.1 pc.2) ^ 2 âˆ‚dgp.jointMeasure
model_star : PhenotypeInformedGAM 1 k 1 :=
  { pgsBasis := model_norm.pgsBasis, pcSplineBasis := model_norm.pcSplineBasis, Î³â‚€â‚€ := 0, Î³â‚˜â‚€ := fun x => 1,
    fâ‚€â‚— := fun x x_1 => 0, fâ‚˜â‚— := fun x x_1 x_2 => 0, link := model_norm.link, dist := model_norm.dist }
h_star_pred : âˆ€ (p : â„) (c : Fin k â†’ â„), linearPredictor model_star p c = p
h_star_in_class : IsNormalizedScoreModel model_star
h_risk_star :
  (expectedSquaredError (dgpMultiplicativeBias scaling_func) fun p c => linearPredictor model_star p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)), ((scaling_func pc.2 - 1) * pc.1) ^ 2 âˆ‚stdNormalProdMeasure k
m : PhenotypeInformedGAM 1 k 1 := model_norm
hm_norm : IsNormalizedScoreModel model_norm
Î¼P : Measure â„ := ProbabilityTheory.gaussianReal 0 1
Î¼C : Measure (Fin k â†’ â„) := Measure.pi fun x => ProbabilityTheory.gaussianReal 0 1
h_prod : stdNormalProdMeasure k = Î¼P.prod Î¼C
thisâœ : IsProbabilityMeasure Î¼P
this : IsProbabilityMeasure Î¼C
h_gauss_moments : âˆ€ (n : â„•), Integrable (fun x => x ^ n) Î¼P
h_p_int : Integrable (fun p => p) Î¼P
h_p2_int : Integrable (fun p => p ^ 2) Î¼P
h_map : Measure.map Prod.snd (stdNormalProdMeasure k) = Î¼C
h_scaling_meas' : AEStronglyMeasurable scaling_func Î¼C
h_scaling_sq_int' : Integrable (fun c => scaling_func c ^ 2) Î¼C
h_S_int : Integrable scaling_func Î¼C
h_Sm1_int : Integrable (fun c => scaling_func c - 1) Î¼C
k_val : â„ := m.Î³â‚˜â‚€ 0
f : â„ Ã— (Fin k â†’ â„) â†’ â„ := fun pc => (predictorBase m pc.2 + k_val * pc.1) ^ 2
h_int_f : Integrable f (Î¼P.prod Î¼C)
c : Fin k â†’ â„
h_poly :
  âˆ€ (p : â„),
    (predictorBase m c + k_val * p) ^ 2 = predictorBase m c ^ 2 + 2 * predictorBase m c * k_val * p + k_val ^ 2 * p ^ 2
âŠ¢ Integrable (fun p => predictorBase m c ^ 2 + 2 * predictorBase m c * k_val * p) Î¼P
error: proofs/Calibrator.lean:4075:10: Type mismatch
  integrable_const ?m.1347
has type
  Integrable (fun x => ?m.1347) ?m.1344
but is expected to have type
  Integrable (fun p => k_val ^ 2 * p ^ 2) Î¼P
error: proofs/Calibrator.lean:4080:8: Type mismatch
  Integrable.sub h_partial_int (integrable_const ?m.1424)
has type
  Integrable ((fun c => predictorBase m c ^ 2 + k_val ^ 2) - fun x => ?m.1424) Î¼C
but is expected to have type
  Integrable (fun c => predictorBase m c ^ 2) Î¼C
error: proofs/Calibrator.lean:4087:18: Unknown constant `MeasureTheory.MemLp.integrable_of_le`
error: proofs/Calibrator.lean:4103:10: `simp` made no progress
error: proofs/Calibrator.lean:4113:63: Unknown constant `ENNReal.one_toReal`
warning: proofs/Calibrator.lean:4114:18: `MeasureTheory.integral_mul_left` has been deprecated: Use `MeasureTheory.integral_const_mul` instead
error: proofs/Calibrator.lean:4114:37: Unknown identifier `integral_id_gaussianReal`
warning: proofs/Calibrator.lean:4116:18: `MeasureTheory.integral_mul_left` has been deprecated: Use `MeasureTheory.integral_const_mul` instead
error: proofs/Calibrator.lean:4116:18: Tactic `rewrite` failed: Did not find an occurrence of the pattern
  âˆ« (a : ?m.1988), ?r * ?f a âˆ‚?m.1990
in the target expression
  Integrable (fun a => predictorBase m c ^ 2) Î¼P

case hf
k : â„•
instâœ : Fintype (Fin k)
scaling_func : (Fin k â†’ â„) â†’ â„
h_scaling_meas : AEStronglyMeasurable scaling_func (Measure.map Prod.snd (stdNormalProdMeasure k))
h_integrable : Integrable (fun pc => (scaling_func pc.2 * pc.1) ^ 2) (stdNormalProdMeasure k)
h_scaling_sq_int : Integrable (fun c => scaling_func c ^ 2) (Measure.map Prod.snd (stdNormalProdMeasure k))
h_mean_1 : âˆ« (c : Fin k â†’ â„), scaling_func c âˆ‚Measure.map Prod.snd (stdNormalProdMeasure k) = 1
model_norm : PhenotypeInformedGAM 1 k 1
h_norm_opt : IsBayesOptimalInNormalizedClass (dgpMultiplicativeBias scaling_func) model_norm
h_linear_basis : model_norm.pgsBasis.B 1 = id âˆ§ model_norm.pgsBasis.B 0 = fun x => 1
h_norm_int : Integrable (fun pc => linearPredictor model_norm pc.1 pc.2 ^ 2) (stdNormalProdMeasure k)
h_base_meas : AEStronglyMeasurable (predictorBase model_norm) (Measure.map Prod.snd (stdNormalProdMeasure k))
model_oracle : PhenotypeInformedGAM 1 k 1
h_oracle_opt : IsBayesOptimalInClass (dgpMultiplicativeBias scaling_func) model_oracle
h_capable :
  âˆƒ m,
    âˆ€ (p_val : â„) (c_val : Fin k â†’ â„),
      linearPredictor m p_val c_val = (dgpMultiplicativeBias scaling_func).trueExpectation p_val c_val
dgp : DataGeneratingProcess k := dgpMultiplicativeBias scaling_func
h_oracle_risk_zero : (expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) = 0
h_diff_eq_norm_sq :
  ((expectedSquaredError dgp fun p c => linearPredictor model_norm p c) -
      expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)),
      (dgp.trueExpectation pc.1 pc.2 - linearPredictor model_norm pc.1 pc.2) ^ 2 âˆ‚dgp.jointMeasure
model_star : PhenotypeInformedGAM 1 k 1 :=
  { pgsBasis := model_norm.pgsBasis, pcSplineBasis := model_norm.pcSplineBasis, Î³â‚€â‚€ := 0, Î³â‚˜â‚€ := fun x => 1,
    fâ‚€â‚— := fun x x_1 => 0, fâ‚˜â‚— := fun x x_1 x_2 => 0, link := model_norm.link, dist := model_norm.dist }
h_star_pred : âˆ€ (p : â„) (c : Fin k â†’ â„), linearPredictor model_star p c = p
h_star_in_class : IsNormalizedScoreModel model_star
h_risk_star :
  (expectedSquaredError (dgpMultiplicativeBias scaling_func) fun p c => linearPredictor model_star p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)), ((scaling_func pc.2 - 1) * pc.1) ^ 2 âˆ‚stdNormalProdMeasure k
m : PhenotypeInformedGAM 1 k 1 := model_norm
hm_norm : IsNormalizedScoreModel model_norm
Î¼P : Measure â„ := ProbabilityTheory.gaussianReal 0 1
Î¼C : Measure (Fin k â†’ â„) := Measure.pi fun x => ProbabilityTheory.gaussianReal 0 1
h_prod : stdNormalProdMeasure k = Î¼P.prod Î¼C
thisâœ : IsProbabilityMeasure Î¼P
this : IsProbabilityMeasure Î¼C
h_gauss_moments : âˆ€ (n : â„•), Integrable (fun x => x ^ n) Î¼P
h_p_int : Integrable (fun p => p) Î¼P
h_p2_int : Integrable (fun p => p ^ 2) Î¼P
h_map : Measure.map Prod.snd (stdNormalProdMeasure k) = Î¼C
h_scaling_meas' : AEStronglyMeasurable scaling_func Î¼C
h_scaling_sq_int' : Integrable (fun c => scaling_func c ^ 2) Î¼C
h_S_int : Integrable scaling_func Î¼C
h_Sm1_int : Integrable (fun c => scaling_func c - 1) Î¼C
h_base_int : Integrable (predictorBase m) Î¼C
h_mem_S_minus_1 : MemLp (fun c => scaling_func c - 1) 2 Î¼C
h_base_meas' : AEStronglyMeasurable (predictorBase m) Î¼C
k_val : â„ := m.Î³â‚˜â‚€ 0
f : â„ Ã— (Fin k â†’ â„) â†’ â„ := fun pc => (predictorBase m pc.2 + k_val * pc.1) ^ 2
h_int_f : Integrable f (Î¼P.prod Î¼C)
c : Fin k â†’ â„
h_poly :
  âˆ€ (p : â„),
    (predictorBase m c + k_val * p) ^ 2 = predictorBase m c ^ 2 + 2 * predictorBase m c * k_val * p + k_val ^ 2 * p ^ 2
âŠ¢ Integrable (fun a => predictorBase m c ^ 2) Î¼P
error: proofs/Calibrator.lean:4118:12: Tactic `apply` failed: could not unify the conclusion of `@Integrable.const_mul`
  Integrable (fun x => ?c * ?f x) ?Î¼
with the goal
  Integrable (fun p => predictorBase m c ^ 2 + 2 * predictorBase m c * k_val * p) Î¼P

Note: The full type of `@Integrable.const_mul` is
  âˆ€ {Î± : Type ?u.340966} {m : MeasurableSpace Î±} {Î¼ : Measure Î±} {ð•œ : Type ?u.340965} [inst : NormedRing ð•œ] {f : Î± â†’ ð•œ},
    Integrable f Î¼ â†’ âˆ€ (c : ð•œ), Integrable (fun x => c * f x) Î¼

case hf
k : â„•
instâœ : Fintype (Fin k)
scaling_func : (Fin k â†’ â„) â†’ â„
h_scaling_meas : AEStronglyMeasurable scaling_func (Measure.map Prod.snd (stdNormalProdMeasure k))
h_integrable : Integrable (fun pc => (scaling_func pc.2 * pc.1) ^ 2) (stdNormalProdMeasure k)
h_scaling_sq_int : Integrable (fun c => scaling_func c ^ 2) (Measure.map Prod.snd (stdNormalProdMeasure k))
h_mean_1 : âˆ« (c : Fin k â†’ â„), scaling_func c âˆ‚Measure.map Prod.snd (stdNormalProdMeasure k) = 1
model_norm : PhenotypeInformedGAM 1 k 1
h_norm_opt : IsBayesOptimalInNormalizedClass (dgpMultiplicativeBias scaling_func) model_norm
h_linear_basis : model_norm.pgsBasis.B 1 = id âˆ§ model_norm.pgsBasis.B 0 = fun x => 1
h_norm_int : Integrable (fun pc => linearPredictor model_norm pc.1 pc.2 ^ 2) (stdNormalProdMeasure k)
h_base_meas : AEStronglyMeasurable (predictorBase model_norm) (Measure.map Prod.snd (stdNormalProdMeasure k))
model_oracle : PhenotypeInformedGAM 1 k 1
h_oracle_opt : IsBayesOptimalInClass (dgpMultiplicativeBias scaling_func) model_oracle
h_capable :
  âˆƒ m,
    âˆ€ (p_val : â„) (c_val : Fin k â†’ â„),
      linearPredictor m p_val c_val = (dgpMultiplicativeBias scaling_func).trueExpectation p_val c_val
dgp : DataGeneratingProcess k := dgpMultiplicativeBias scaling_func
h_oracle_risk_zero : (expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) = 0
h_diff_eq_norm_sq :
  ((expectedSquaredError dgp fun p c => linearPredictor model_norm p c) -
      expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)),
      (dgp.trueExpectation pc.1 pc.2 - linearPredictor model_norm pc.1 pc.2) ^ 2 âˆ‚dgp.jointMeasure
model_star : PhenotypeInformedGAM 1 k 1 :=
  { pgsBasis := model_norm.pgsBasis, pcSplineBasis := model_norm.pcSplineBasis, Î³â‚€â‚€ := 0, Î³â‚˜â‚€ := fun x => 1,
    fâ‚€â‚— := fun x x_1 => 0, fâ‚˜â‚— := fun x x_1 x_2 => 0, link := model_norm.link, dist := model_norm.dist }
h_star_pred : âˆ€ (p : â„) (c : Fin k â†’ â„), linearPredictor model_star p c = p
h_star_in_class : IsNormalizedScoreModel model_star
h_risk_star :
  (expectedSquaredError (dgpMultiplicativeBias scaling_func) fun p c => linearPredictor model_star p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)), ((scaling_func pc.2 - 1) * pc.1) ^ 2 âˆ‚stdNormalProdMeasure k
m : PhenotypeInformedGAM 1 k 1 := model_norm
hm_norm : IsNormalizedScoreModel model_norm
Î¼P : Measure â„ := ProbabilityTheory.gaussianReal 0 1
Î¼C : Measure (Fin k â†’ â„) := Measure.pi fun x => ProbabilityTheory.gaussianReal 0 1
h_prod : stdNormalProdMeasure k = Î¼P.prod Î¼C
thisâœ : IsProbabilityMeasure Î¼P
this : IsProbabilityMeasure Î¼C
h_gauss_moments : âˆ€ (n : â„•), Integrable (fun x => x ^ n) Î¼P
h_p_int : Integrable (fun p => p) Î¼P
h_p2_int : Integrable (fun p => p ^ 2) Î¼P
h_map : Measure.map Prod.snd (stdNormalProdMeasure k) = Î¼C
h_scaling_meas' : AEStronglyMeasurable scaling_func Î¼C
h_scaling_sq_int' : Integrable (fun c => scaling_func c ^ 2) Î¼C
h_S_int : Integrable scaling_func Î¼C
h_Sm1_int : Integrable (fun c => scaling_func c - 1) Î¼C
h_base_int : Integrable (predictorBase m) Î¼C
h_mem_S_minus_1 : MemLp (fun c => scaling_func c - 1) 2 Î¼C
h_base_meas' : AEStronglyMeasurable (predictorBase m) Î¼C
k_val : â„ := m.Î³â‚˜â‚€ 0
f : â„ Ã— (Fin k â†’ â„) â†’ â„ := fun pc => (predictorBase m pc.2 + k_val * pc.1) ^ 2
h_int_f : Integrable f (Î¼P.prod Î¼C)
c : Fin k â†’ â„
h_poly :
  âˆ€ (p : â„),
    (predictorBase m c + k_val * p) ^ 2 = predictorBase m c ^ 2 + 2 * predictorBase m c * k_val * p + k_val ^ 2 * p ^ 2
âŠ¢ Integrable (fun p => predictorBase m c ^ 2 + 2 * predictorBase m c * k_val * p) Î¼P
error: proofs/Calibrator.lean:4119:12: Type mismatch
  integrable_const ?m.2017
has type
  Integrable (fun x => ?m.2017) ?m.2014
but is expected to have type
  Integrable (fun p => k_val ^ 2 * p ^ 2) Î¼P
error: proofs/Calibrator.lean:4122:8: Type mismatch
  Integrable.sub h_partial_int (integrable_const ?m.2065)
has type
  Integrable ((fun c => predictorBase m c ^ 2 + k_val ^ 2) - fun x => ?m.2065) Î¼C
but is expected to have type
  Integrable (fun c => predictorBase m c ^ 2) Î¼C
error: proofs/Calibrator.lean:3983:78: unsolved goals
k : â„•
instâœ : Fintype (Fin k)
scaling_func : (Fin k â†’ â„) â†’ â„
h_scaling_meas : AEStronglyMeasurable scaling_func (Measure.map Prod.snd (stdNormalProdMeasure k))
h_integrable : Integrable (fun pc => (scaling_func pc.2 * pc.1) ^ 2) (stdNormalProdMeasure k)
h_scaling_sq_int : Integrable (fun c => scaling_func c ^ 2) (Measure.map Prod.snd (stdNormalProdMeasure k))
h_mean_1 : âˆ« (c : Fin k â†’ â„), scaling_func c âˆ‚Measure.map Prod.snd (stdNormalProdMeasure k) = 1
model_norm : PhenotypeInformedGAM 1 k 1
h_norm_opt : IsBayesOptimalInNormalizedClass (dgpMultiplicativeBias scaling_func) model_norm
h_linear_basis : model_norm.pgsBasis.B 1 = id âˆ§ model_norm.pgsBasis.B 0 = fun x => 1
h_norm_int : Integrable (fun pc => linearPredictor model_norm pc.1 pc.2 ^ 2) (stdNormalProdMeasure k)
h_base_meas : AEStronglyMeasurable (predictorBase model_norm) (Measure.map Prod.snd (stdNormalProdMeasure k))
model_oracle : PhenotypeInformedGAM 1 k 1
h_oracle_opt : IsBayesOptimalInClass (dgpMultiplicativeBias scaling_func) model_oracle
h_capable :
  âˆƒ m,
    âˆ€ (p_val : â„) (c_val : Fin k â†’ â„),
      linearPredictor m p_val c_val = (dgpMultiplicativeBias scaling_func).trueExpectation p_val c_val
dgp : DataGeneratingProcess k := dgpMultiplicativeBias scaling_func
h_oracle_risk_zero : (expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) = 0
h_diff_eq_norm_sq :
  ((expectedSquaredError dgp fun p c => linearPredictor model_norm p c) -
      expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)),
      (dgp.trueExpectation pc.1 pc.2 - linearPredictor model_norm pc.1 pc.2) ^ 2 âˆ‚dgp.jointMeasure
model_star : PhenotypeInformedGAM 1 k 1 :=
  { pgsBasis := model_norm.pgsBasis, pcSplineBasis := model_norm.pcSplineBasis, Î³â‚€â‚€ := 0, Î³â‚˜â‚€ := fun x => 1,
    fâ‚€â‚— := fun x x_1 => 0, fâ‚˜â‚— := fun x x_1 x_2 => 0, link := model_norm.link, dist := model_norm.dist }
h_star_pred : âˆ€ (p : â„) (c : Fin k â†’ â„), linearPredictor model_star p c = p
h_star_in_class : IsNormalizedScoreModel model_star
h_risk_star :
  (expectedSquaredError (dgpMultiplicativeBias scaling_func) fun p c => linearPredictor model_star p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)), ((scaling_func pc.2 - 1) * pc.1) ^ 2 âˆ‚stdNormalProdMeasure k
m : PhenotypeInformedGAM 1 k 1 := model_norm
hm_norm : IsNormalizedScoreModel model_norm
Î¼P : Measure â„ := ProbabilityTheory.gaussianReal 0 1
Î¼C : Measure (Fin k â†’ â„) := Measure.pi fun x => ProbabilityTheory.gaussianReal 0 1
h_prod : stdNormalProdMeasure k = Î¼P.prod Î¼C
thisâœ : IsProbabilityMeasure Î¼P
this : IsProbabilityMeasure Î¼C
h_gauss_moments : âˆ€ (n : â„•), Integrable (fun x => x ^ n) Î¼P
h_p_int : Integrable (fun p => p) Î¼P
h_p2_int : Integrable (fun p => p ^ 2) Î¼P
h_map : Measure.map Prod.snd (stdNormalProdMeasure k) = Î¼C
h_scaling_meas' : AEStronglyMeasurable scaling_func Î¼C
h_scaling_sq_int' : Integrable (fun c => scaling_func c ^ 2) Î¼C
h_S_int : Integrable scaling_func Î¼C
h_Sm1_int : Integrable (fun c => scaling_func c - 1) Î¼C
h_base_int : Integrable (predictorBase m) Î¼C
h_Sm1_base_int : Integrable (fun c => (scaling_func c - 1) * predictorBase m c) Î¼C
âŠ¢ (expectedSquaredError dgp fun p c => linearPredictor model_norm p c) â‰¥
    expectedSquaredError dgp fun p c => linearPredictor model_star p c
error: proofs/Calibrator.lean:3931:66: unsolved goals
k : â„•
instâœ : Fintype (Fin k)
scaling_func : (Fin k â†’ â„) â†’ â„
h_scaling_meas : AEStronglyMeasurable scaling_func (Measure.map Prod.snd (stdNormalProdMeasure k))
h_integrable : Integrable (fun pc => (scaling_func pc.2 * pc.1) ^ 2) (stdNormalProdMeasure k)
h_scaling_sq_int : Integrable (fun c => scaling_func c ^ 2) (Measure.map Prod.snd (stdNormalProdMeasure k))
h_mean_1 : âˆ« (c : Fin k â†’ â„), scaling_func c âˆ‚Measure.map Prod.snd (stdNormalProdMeasure k) = 1
model_norm : PhenotypeInformedGAM 1 k 1
h_norm_opt : IsBayesOptimalInNormalizedClass (dgpMultiplicativeBias scaling_func) model_norm
h_linear_basis : model_norm.pgsBasis.B 1 = id âˆ§ model_norm.pgsBasis.B 0 = fun x => 1
h_norm_int : Integrable (fun pc => linearPredictor model_norm pc.1 pc.2 ^ 2) (stdNormalProdMeasure k)
h_base_meas : AEStronglyMeasurable (predictorBase model_norm) (Measure.map Prod.snd (stdNormalProdMeasure k))
model_oracle : PhenotypeInformedGAM 1 k 1
h_oracle_opt : IsBayesOptimalInClass (dgpMultiplicativeBias scaling_func) model_oracle
h_capable :
  âˆƒ m,
    âˆ€ (p_val : â„) (c_val : Fin k â†’ â„),
      linearPredictor m p_val c_val = (dgpMultiplicativeBias scaling_func).trueExpectation p_val c_val
dgp : DataGeneratingProcess k := dgpMultiplicativeBias scaling_func
h_oracle_risk_zero : (expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) = 0
h_diff_eq_norm_sq :
  ((expectedSquaredError dgp fun p c => linearPredictor model_norm p c) -
      expectedSquaredError dgp fun p c => linearPredictor model_oracle p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)),
      (dgp.trueExpectation pc.1 pc.2 - linearPredictor model_norm pc.1 pc.2) ^ 2 âˆ‚dgp.jointMeasure
model_star : PhenotypeInformedGAM 1 k 1 :=
  { pgsBasis := model_norm.pgsBasis, pcSplineBasis := model_norm.pcSplineBasis, Î³â‚€â‚€ := 0, Î³â‚˜â‚€ := fun x => 1,
    fâ‚€â‚— := fun x x_1 => 0, fâ‚˜â‚— := fun x x_1 x_2 => 0, link := model_norm.link, dist := model_norm.dist }
h_star_pred : âˆ€ (p : â„) (c : Fin k â†’ â„), linearPredictor model_star p c = p
h_star_in_class : IsNormalizedScoreModel model_star
h_risk_star :
  (expectedSquaredError (dgpMultiplicativeBias scaling_func) fun p c => linearPredictor model_star p c) =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)), ((scaling_func pc.2 - 1) * pc.1) ^ 2 âˆ‚stdNormalProdMeasure k
h_risk_lower_bound :
  (expectedSquaredError dgp fun p c => linearPredictor model_norm p c) â‰¥
    expectedSquaredError dgp fun p c => linearPredictor model_star p c
âŠ¢ âˆ« (pc : â„ Ã— (Fin k â†’ â„)),
      (dgp.trueExpectation pc.1 pc.2 - linearPredictor model_norm pc.1 pc.2) ^ 2 âˆ‚dgp.jointMeasure =
    âˆ« (pc : â„ Ã— (Fin k â†’ â„)), ((scaling_func pc.2 - 1) * pc.1) ^ 2 âˆ‚(dgpMultiplicativeBias scaling_func).jointMeasure
warning: proofs/Calibrator.lean:4489:8: declaration uses 'sorry'
warning: proofs/Calibrator.lean:4562:44: unused variable `h_opt1`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
warning: proofs/Calibrator.lean:5432:10: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:5451:14: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
warning: proofs/Calibrator.lean:5418:8: This simp argument is unused:
  Matrix.diagonal_apply

Hint: Omit it from the simp argument list.
  simp Ìµ[ÌµMÌµaÌµtÌµrÌµiÌµxÌµ.ÌµdÌµiÌµaÌµgÌµoÌµnÌµaÌµlÌµ_ÌµaÌµpÌµpÌµlÌµyÌµ]Ìµ

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:5487:31: This simp argument is unused:
  Matrix.transpose_apply

Hint: Omit it from the simp argument list.
  simp only [Matrix.mul_apply, MÌµaÌµtÌµrÌµiÌµxÌµ.ÌµtÌµrÌµaÌµnÌµsÌµpÌµoÌµsÌµeÌµ_ÌµaÌµpÌµpÌµlÌµyÌµ,Ìµ ÌµsumToZeroConstraint]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:5487:55: This simp argument is unused:
  sumToZeroConstraint

Hint: Omit it from the simp argument list.
  simp only [Matrix.mul_apply, Matrix.transpose_apply,Ìµ ÌµsÌµuÌµmÌµTÌµoÌµZÌµeÌµrÌµoÌµCÌµoÌµnÌµsÌµtÌµrÌµaÌµiÌµnÌµtÌµ]

Note: This linter can be disabled with `set_option linter.unusedSimpArgs false`
warning: proofs/Calibrator.lean:6065:41: unused variable `hÎ¼_pos`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
warning: proofs/Calibrator.lean:6133:229: unused variable `log_lik`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
warning: proofs/Calibrator.lean:6144:8: declaration uses 'sorry'
error: Lean exited with code 1
Some required targets logged failures:
- Calibrator
error: build failed
