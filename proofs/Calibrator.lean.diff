<<<<<<< SEARCH
/-- Orthogonal projection onto a finite-dimensional subspace. -/
noncomputable def orthogonalProjection {n : ℕ} (K : Submodule ℝ (Fin n → ℝ)) (y : Fin n → ℝ) : Fin n → ℝ :=
  let iso := WithLp.linearEquiv 2 ℝ (Fin n → ℝ)
  let K' : Submodule ℝ (WithLp 2 (Fin n → ℝ)) := K.map iso.symm
  let y' : WithLp 2 (Fin n → ℝ) := iso.symm y
  let p' : WithLp 2 (Fin n → ℝ) := Submodule.orthogonalProjection K' y'
  iso p'

/-- A point p in subspace K equals the orthogonal projection of y onto K
    iff p minimizes distance to y among all points in K. -/
lemma orthogonalProjection_eq_of_dist_le {n : ℕ} (K : Submodule ℝ (Fin n → ℝ)) (y p : Fin n → ℝ)
    (h_mem : p ∈ K)
    (h_min : ∀ w ∈ K, dist (WithLp.equiv 2 (Fin n → ℝ).symm p) (WithLp.equiv 2 (Fin n → ℝ).symm y) ≤
                      dist (WithLp.equiv 2 (Fin n → ℝ).symm w) (WithLp.equiv 2 (Fin n → ℝ).symm y)) :
    p = orthogonalProjection K y := by
  let iso := WithLp.linearEquiv 2 ℝ (Fin n → ℝ)
  let K' : Submodule ℝ (WithLp 2 (Fin n → ℝ)) := K.map iso.symm
  let y' : WithLp 2 (Fin n → ℝ) := iso.symm y
  let p' : WithLp 2 (Fin n → ℝ) := iso.symm p

  -- Verify p' is in K'
  have h_mem' : p' ∈ K' := by
    rw [Submodule.mem_map]
    use p
    simp [h_mem]

  -- Verify p' minimizes distance to y' in K'
  have h_min' : ∀ w' ∈ K', dist y' p' ≤ dist y' w' := by
    intro w' hw'
    rw [Submodule.mem_map] at hw'
    rcases hw' with ⟨w, hw, rfl⟩
    -- The hypothesis h_min refers to dist (iso.symm p) (iso.symm y)
    -- Which is dist p' y'
    -- We want to use h_min for w
    specialize h_min w hw
    -- dist is symmetric
    rw [dist_comm y' p']
    rw [dist_comm y' (iso.symm w)]
    convert h_min using 0

  -- Apply the standard theorem for orthogonal projection in Hilbert space
  -- We rely on the fact that `WithLp 2 (Fin n → ℝ)` is an `InnerProductSpace`.
  -- Mathlib provides `InnerProductSpace.ofCore` for `PiLp` but we need to ensure instance is found.
  -- The imports include `Mathlib.Analysis.InnerProductSpace.PiL2`.
  have h_eq' := Submodule.eq_orthogonalProjection_of_mem_of_min_dist K' y' p' h_mem' h_min'

  -- Map back to the original space
  unfold orthogonalProjection
  dsimp
  rw [← h_eq']
  simp
=======
/-- Orthogonal projection onto a finite-dimensional subspace. -/
noncomputable def orthogonalProjection {n : ℕ} (K : Submodule ℝ (Fin n → ℝ)) (y : Fin n → ℝ) : Fin n → ℝ :=
  let iso := WithLp.linearEquiv 2 ℝ (Fin n → ℝ)
  let K' : Submodule ℝ (WithLp 2 (Fin n → ℝ)) := K.map iso.symm
  let y' : WithLp 2 (Fin n → ℝ) := iso.symm y
  let p' : WithLp 2 (Fin n → ℝ) := Submodule.orthogonalProjection K' y'
  iso p'

/-- A point p in subspace K equals the orthogonal projection of y onto K
    iff p minimizes distance to y among all points in K. -/
lemma orthogonalProjection_eq_of_dist_le {n : ℕ} (K : Submodule ℝ (Fin n → ℝ)) (y p : Fin n → ℝ)
    (h_mem : p ∈ K)
    (h_min : ∀ w ∈ K, dist (WithLp.equiv 2 (Fin n → ℝ).symm p) (WithLp.equiv 2 (Fin n → ℝ).symm y) ≤
                      dist (WithLp.equiv 2 (Fin n → ℝ).symm w) (WithLp.equiv 2 (Fin n → ℝ).symm y)) :
    p = orthogonalProjection K y := by
  let iso := WithLp.linearEquiv 2 ℝ (Fin n → ℝ)
  let K' : Submodule ℝ (WithLp 2 (Fin n → ℝ)) := K.map iso.symm
  let y' : WithLp 2 (Fin n → ℝ) := iso.symm y
  let p' : WithLp 2 (Fin n → ℝ) := iso.symm p

  -- Verify p' is in K'
  have h_mem' : p' ∈ K' := by
    rw [Submodule.mem_map]
    use p
    simp [h_mem]

  -- Verify p' minimizes distance to y' in K'
  have h_min' : ∀ w' ∈ K', dist y' p' ≤ dist y' w' := by
    intro w' hw'
    rw [Submodule.mem_map] at hw'
    rcases hw' with ⟨w, hw, rfl⟩
    specialize h_min w hw
    -- dist is symmetric, and iso.symm w corresponds to the arguments in h_min
    have : (WithLp.equiv 2 (Fin n → ℝ)).symm = iso.symm := rfl
    rw [this] at h_min

    have h_dist_eq : dist y' p' = dist (iso.symm p) (iso.symm y) := by
      rw [dist_comm]; rfl
    rw [h_dist_eq]
    exact h_min

  -- Apply the standard theorem for orthogonal projection in Hilbert space
  -- Since WithLp 2 is a Hilbert space (InnerProductSpace), the projection is the unique minimizer
  -- of distance.
  -- Theorem: Submodule.is_orthogonalProjection_iff_dist_le
  -- Or: orthogonalProjection_eq_of_mem_of_prop
  -- Correct theorem: eq_orthogonalProjection_of_mem_of_min_dist (not in Submodule namespace?)
  -- Actually, let's use the property that orthogonal projection minimizes distance.
  -- Then use uniqueness.

  have h_proj_min : ∀ w' ∈ K', dist y' (Submodule.orthogonalProjection K' y') ≤ dist y' w' :=
    Submodule.orthogonalProjection_is_minimizer K' y'

  have h_unique : p' = Submodule.orthogonalProjection K' y' := by
    apply Eq.symm
    apply Submodule.eq_orthogonalProjection_of_mem_of_min_dist K' y' p' h_mem' h_min'

  -- Map back to the original space
  unfold orthogonalProjection
  dsimp
  rw [← h_unique]
  simp
>>>>>>> REPLACE
<<<<<<< SEARCH
                have h_prod_rule : ∀ (f : m → ℝ → ℝ), (∀ i, DifferentiableAt ℝ (f i) rho) → deriv (fun rho => ∏ i, f i rho) rho = ∑ i, (∏ j ∈ Finset.univ.erase i, f j rho) * deriv (f i) rho := by
                  intro f hf
                  convert deriv_finset_prod Finset.univ f (fun i _ => hf i)
                  simp
                apply h_prod_rule
                intro i
                exact DifferentiableAt.comp rho ( differentiableAt_pi.1 ( differentiableAt_pi.1 hM_diff _ ) _ ) differentiableAt_id
              have h_deriv_sum : deriv (fun rho => ∑ σ : Equiv.Perm m, (↑(↑((Equiv.Perm.sign : Equiv.Perm m → ℤˣ) σ) : ℤ) : ℝ) * ∏ i : m, M rho ((σ : m → m) i) i) rho = ∑ σ : Equiv.Perm m, (↑(↑((Equiv.Perm.sign : Equiv.Perm m → ℤˣ) σ) : ℤ) : ℝ) * deriv (fun rho => ∏ i : m, M rho ((σ : m → m) i) i) rho := by
                have h_diff : ∀ σ : Equiv.Perm m, DifferentiableAt ℝ (fun rho => ∏ i : m, M rho ((σ : m → m) i) i) rho := by
                  intro σ
                  have h_diff : ∀ i : m, DifferentiableAt ℝ (fun rho => M rho ((σ : m → m) i) i) rho := by
                    intro i
                    exact DifferentiableAt.comp rho ( differentiableAt_pi.1 ( differentiableAt_pi.1 hM_diff _ ) _ ) differentiableAt_id
                  apply DifferentiableAt.finset_prod
                  intro i _
                  exact h_diff i
=======
                have h_prod_rule : ∀ (f : m → ℝ → ℝ), (∀ i, DifferentiableAt ℝ (f i) rho) → deriv (fun rho => ∏ i, f i rho) rho = ∑ i, (∏ j ∈ Finset.univ.erase i, f j rho) * deriv (f i) rho := by
                  intro f hf
                  rw [deriv_finset_prod]
                  · rfl
                  · exact fun i _ => hf i
                apply h_prod_rule
                intro i
                exact DifferentiableAt.comp rho ( differentiableAt_pi.1 ( differentiableAt_pi.1 hM_diff _ ) _ ) differentiableAt_id
              have h_deriv_sum : deriv (fun rho => ∑ σ : Equiv.Perm m, (↑(↑((Equiv.Perm.sign : Equiv.Perm m → ℤˣ) σ) : ℤ) : ℝ) * ∏ i : m, M rho ((σ : m → m) i) i) rho = ∑ σ : Equiv.Perm m, (↑(↑((Equiv.Perm.sign : Equiv.Perm m → ℤˣ) σ) : ℤ) : ℝ) * deriv (fun rho => ∏ i : m, M rho ((σ : m → m) i) i) rho := by
                have h_diff : ∀ σ : Equiv.Perm m, DifferentiableAt ℝ (fun rho => ∏ i : m, M rho ((σ : m → m) i) i) rho := by
                  intro σ
                  have h_diff : ∀ i : m, DifferentiableAt ℝ (fun rho => M rho ((σ : m → m) i) i) rho := by
                    intro i
                    exact DifferentiableAt.comp rho ( differentiableAt_pi.1 ( differentiableAt_pi.1 hM_diff _ ) _ ) differentiableAt_id
                  apply DifferentiableAt.finset_prod
                  intro i _
                  exact h_diff i
>>>>>>> REPLACE
<<<<<<< SEARCH
      have h_integrand : ∀ pc : ℝ × (Fin k → ℝ),
          (dgp.trueExpectation pc.1 pc.2 - pc.1) * (pc.1 - linearPredictor model_norm pc.1 pc.2) =
          (1 - γ) * ((scaling_func pc.2 - 1) * pc.1^2) - ((scaling_func pc.2 - 1) * base pc.2) * pc.1 := by
        intro pc
        dsimp [dgp, dgpMultiplicativeBias]
        rw [h_diff_form]
        ring
=======
      have h_integrand : ∀ pc : ℝ × (Fin k → ℝ),
          (dgp.trueExpectation pc.1 pc.2 - pc.1) * (pc.1 - linearPredictor model_norm pc.1 pc.2) =
          (1 - γ) * ((scaling_func pc.2 - 1) * pc.1^2) - ((scaling_func pc.2 - 1) * base pc.2) * pc.1 := by
        intro pc
        dsimp [dgp, dgpMultiplicativeBias]
        -- Expand linearPredictor
        have h_pred : linearPredictor model_norm pc.1 pc.2 = base pc.2 + γ * pc.1 := by
          rw [h_norm_decomp, h_norm_slope]
          rfl
        rw [h_pred]
        ring
>>>>>>> REPLACE
